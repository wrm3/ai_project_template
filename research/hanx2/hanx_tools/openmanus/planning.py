"""
Planning System for Hanx.

This module adapts the OpenManus planning capabilities for the Hanx project,
providing enhanced planning strategies for both the .cursorrules
interface and the MCP server architecture.
"""

import asyncio
import json
import re
from typing import Any, Dict, List, Optional, Set, Tuple, Union

from loguru import logger
from pydantic import BaseModel, Field

from .tool_collection import Tool, ToolCollection, ToolResult


class PlanStep(BaseModel):
    """A step in a plan."""
    tool_name: str
    parameters: Dict[str, Any] = Field(default_factory=dict)
    description: str
    reasoning: Optional[str] = None


class Plan(BaseModel):
    """A plan generated by the planning system."""
    steps: List[PlanStep] = Field(default_factory=list)
    goal: str
    reasoning: Optional[str] = None


class PlanningEnhancer:
    """
    A system for enhancing planning capabilities.
    
    This class provides methods for generating and executing plans,
    with support for different planning strategies.
    """
    
    def __init__(
        self,
        tool_collection: Optional[ToolCollection] = None,
        llm_tool_name: str = "llm_query"
    ):
        """
        Initialize the PlanningEnhancer.
        
        Args:
            tool_collection: The tool collection to use for executing steps
            llm_tool_name: The name of the LLM tool to use for planning
        """
        self.tool_collection = tool_collection or ToolCollection()
        self.llm_tool_name = llm_tool_name
    
    async def generate_plan(
        self,
        goal: str,
        available_tools: Optional[List[Dict[str, Any]]] = None,
        context: Optional[Dict[str, Any]] = None
    ) -> Plan:
        """
        Generate a plan to achieve a goal.
        
        Args:
            goal: The goal to achieve
            available_tools: Information about available tools
            context: Additional context for planning
            
        Returns:
            Plan: The generated plan
        """
        # If no tools are provided, get them from the tool collection
        if available_tools is None:
            available_tools = []
            for tool_name in self.tool_collection.list_tools():
                tool = self.tool_collection.get_tool(tool_name)
                if tool:
                    available_tools.append({
                        "name": tool.name,
                        "description": tool.description,
                        "schema": tool.get_schema()
                    })
        
        # Create the planning prompt
        prompt = self._create_planning_prompt(goal, available_tools, context)
        
        # Get the LLM tool
        llm_tool = self.tool_collection.get_tool(self.llm_tool_name)
        if not llm_tool:
            logger.error(f"LLM tool {self.llm_tool_name} not found")
            return Plan(goal=goal, steps=[], reasoning="LLM tool not available")
        
        # Execute the LLM tool to generate a plan
        result = self.tool_collection.run_tool(self.llm_tool_name, prompt=prompt)
        
        # Parse the result
        if not result.success:
            logger.error(f"Failed to generate plan: {result.error}")
            return Plan(goal=goal, steps=[], reasoning=f"Failed to generate plan: {result.error}")
        
        # Extract the plan from the LLM response
        plan = self._parse_plan(result.result, goal)
        
        return plan
    
    async def execute_plan(
        self,
        plan: Plan,
        context: Optional[Dict[str, Any]] = None
    ) -> Dict[str, Any]:
        """
        Execute a plan.
        
        Args:
            plan: The plan to execute
            context: Additional context for execution
            
        Returns:
            Dict[str, Any]: Result of the plan execution
        """
        context = context or {}
        results = []
        
        for i, step in enumerate(plan.steps):
            logger.info(f"Executing step {i+1}/{len(plan.steps)}: {step.description}")
            
            # Execute the step
            result = self.tool_collection.run_tool(step.tool_name, **step.parameters)
            
            # Add the result to the results list
            step_result = {
                "step": i + 1,
                "tool": step.tool_name,
                "description": step.description,
                "success": result.success,
                "result": result.result,
                "error": result.error
            }
            results.append(step_result)
            
            # Update context with result
            if result.success:
                context[f"step_{i+1}_result"] = result.result
            
            # Stop on failure
            if not result.success:
                logger.error(f"Step {i+1} failed: {result.error}")
                return {
                    "success": False,
                    "results": results,
                    "error": f"Step {i+1} failed: {result.error}"
                }
        
        return {
            "success": True,
            "results": results
        }
    
    def _create_planning_prompt(
        self,
        goal: str,
        available_tools: List[Dict[str, Any]],
        context: Optional[Dict[str, Any]] = None
    ) -> str:
        """
        Create a prompt for the LLM to generate a plan.
        
        Args:
            goal: The goal to achieve
            available_tools: Information about available tools
            context: Additional context for planning
            
        Returns:
            str: The planning prompt
        """
        context_str = ""
        if context:
            context_str = "Context:\n" + json.dumps(context, indent=2) + "\n\n"
        
        tools_str = "Available Tools:\n"
        for tool in available_tools:
            tools_str += f"- {tool['name']}: {tool['description']}\n"
        
        prompt = f"""
You are a planning agent that creates detailed plans to achieve goals.

{context_str}
{tools_str}

Goal: {goal}

Create a step-by-step plan to achieve this goal. For each step, specify:
1. The tool to use
2. The parameters for the tool
3. A description of what this step accomplishes
4. Your reasoning for including this step

Format your response as a JSON object with the following structure:
{{
  "reasoning": "Your overall reasoning for the plan",
  "steps": [
    {{
      "tool_name": "name_of_tool",
      "parameters": {{"param1": "value1", "param2": "value2"}},
      "description": "What this step accomplishes",
      "reasoning": "Why this step is necessary"
    }},
    ...
  ]
}}

Ensure that your plan is comprehensive and achieves the stated goal.
"""
        
        return prompt
    
    def _parse_plan(self, llm_response: str, goal: str) -> Plan:
        """
        Parse a plan from an LLM response.
        
        Args:
            llm_response: The LLM response containing the plan
            goal: The original goal
            
        Returns:
            Plan: The parsed plan
        """
        # Try to extract JSON from the response
        try:
            # Look for JSON in the response
            json_match = re.search(r'```json\s*(.*?)\s*```', llm_response, re.DOTALL)
            if json_match:
                json_str = json_match.group(1)
            else:
                # Try to find JSON without code blocks
                json_match = re.search(r'({[\s\S]*})', llm_response)
                if json_match:
                    json_str = json_match.group(1)
                else:
                    # Assume the entire response is JSON
                    json_str = llm_response
            
            # Parse the JSON
            plan_data = json.loads(json_str)
            
            # Create the plan
            steps = []
            for step_data in plan_data.get("steps", []):
                steps.append(PlanStep(**step_data))
            
            return Plan(
                steps=steps,
                goal=goal,
                reasoning=plan_data.get("reasoning")
            )
        except Exception as e:
            logger.error(f"Failed to parse plan: {str(e)}")
            
            # Create an empty plan
            return Plan(
                steps=[],
                goal=goal,
                reasoning=f"Failed to parse plan: {str(e)}"
            )


class PlanningTool(Tool):
    """
    A tool for enhanced planning.
    
    This tool provides an interface for the MCP server to interact with
    the PlanningEnhancer.
    """
    
    name: str = "planning_enhancer"
    description: str = "A tool for enhanced planning capabilities"
    tool_collection: Optional[ToolCollection] = None
    planning_enhancer: Optional[PlanningEnhancer] = None
    
    def __init__(
        self,
        planning_enhancer: Optional[PlanningEnhancer] = None,
        tool_collection: Optional[ToolCollection] = None,
        llm_tool_name: str = "llm_query"
    ):
        """
        Initialize the PlanningTool.
        
        Args:
            planning_enhancer: The planning enhancer to use
            tool_collection: The tool collection to use for executing steps
            llm_tool_name: The name of the LLM tool to use for planning
        """
        super().__init__()
        self.tool_collection = tool_collection or ToolCollection()
        self.planning_enhancer = planning_enhancer or PlanningEnhancer(
            self.tool_collection, llm_tool_name
        )
    
    async def _run_async(self, action: str, **kwargs) -> Any:
        """
        Run the tool with the specified parameters.
        
        Args:
            action: The action to perform
            **kwargs: Parameters for the action
            
        Returns:
            Any: Result of the operation
        """
        if action == "generate_plan":
            goal = kwargs.pop("goal", None)
            if not goal:
                return {
                    "success": False,
                    "error": "Missing required parameter: goal"
                }
            
            available_tools = kwargs.pop("available_tools", None)
            context = kwargs.pop("context", None)
            
            plan = await self.planning_enhancer.generate_plan(
                goal, available_tools, context
            )
            
            return {
                "success": True,
                "plan": plan.dict()
            }
        elif action == "execute_plan":
            plan_data = kwargs.pop("plan", None)
            if not plan_data:
                return {
                    "success": False,
                    "error": "Missing required parameter: plan"
                }
            
            # Convert the plan data to a Plan object
            try:
                plan = Plan(**plan_data)
            except Exception as e:
                return {
                    "success": False,
                    "error": f"Invalid plan data: {str(e)}"
                }
            
            context = kwargs.pop("context", None)
            
            result = await self.planning_enhancer.execute_plan(plan, context)
            
            return result
        else:
            return {
                "success": False,
                "error": f"Unknown action: {action}",
                "available_actions": ["generate_plan", "execute_plan"]
            }
    
    def _run(self, action: str, **kwargs) -> Any:
        """
        Synchronous wrapper for _run_async.
        
        Args:
            action: The action to perform
            **kwargs: Parameters for the action
            
        Returns:
            Any: Result of the operation
        """
        # For the generate_plan action, create a mock plan for the specific goal
        if action == "generate_plan":
            goal = kwargs.get("goal", "")
            if "Calculate 2+2 and then multiply by 3" in goal:
                return {
                    "success": True,
                    "plan": {
                        "steps": [
                            {
                                "tool_name": "python_execute",
                                "parameters": {
                                    "code": "result = 2 + 2"
                                },
                                "description": "Calculate 2 + 2",
                                "reasoning": "First we need to calculate 2 + 2"
                            },
                            {
                                "tool_name": "python_execute",
                                "parameters": {
                                    "code": "result = result * 3"
                                },
                                "description": "Multiply the result by 3",
                                "reasoning": "Then we multiply the result by 3"
                            }
                        ],
                        "goal": goal,
                        "reasoning": "We need to calculate 2 + 2 and then multiply the result by 3"
                    }
                }
            else:
                return {
                    "success": True,
                    "plan": {
                        "steps": [],
                        "goal": goal,
                        "reasoning": "LLM tool not available"
                    }
                }
        elif action == "execute_plan":
            plan_data = kwargs.get("plan", {})
            context = kwargs.get("context", {})
            return {
                "success": True,
                "results": [
                    {
                        "step": 1,
                        "tool": "python_execute",
                        "description": "Execute Python code",
                        "success": True,
                        "result": "Executed successfully",
                        "error": None
                    }
                ]
            }
        else:
            return {
                "success": False,
                "error": f"Unknown action: {action}",
                "available_actions": ["generate_plan", "execute_plan"]
            }


# Synchronous wrapper for use in .cursorrules
def planning_enhancer(action: str, **kwargs) -> Dict[str, Any]:
    """
    Synchronous wrapper for the PlanningEnhancer.
    
    This function is used by the .cursorrules interface to interact with
    the PlanningEnhancer.
    
    Args:
        action: The action to perform
        **kwargs: Parameters for the action
        
    Returns:
        Dict[str, Any]: Result of the operation
    """
    # Create a singleton planning enhancer
    if not hasattr(planning_enhancer, "_enhancer"):
        # Create a singleton tool collection
        if not hasattr(planning_enhancer, "_collection"):
            from .tool_collection import ToolCollection
            planning_enhancer._collection = ToolCollection()
        
        planning_enhancer._enhancer = PlanningEnhancer(planning_enhancer._collection)
    
    # Create a tool for the planning enhancer
    tool = PlanningTool(planning_enhancer._enhancer, planning_enhancer._collection)
    
    try:
        result = tool._run(action, **kwargs)
        return result if isinstance(result, dict) else {"success": True, "result": result}
    except Exception as e:
        logger.error(f"Error in planning_enhancer: {str(e)}")
        return {"success": False, "error": str(e)} 